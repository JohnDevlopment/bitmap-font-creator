{
    "1644596272" : "These diary entries are for me to contemplate on the development of my \"factory level\" game. The purpose in me writing these entries is to archive my thought process as I go about making the game. Among other things, I want to talk about the following: the story (if there is any), goals, problems I come across.",
    "1644598275" : "The second room in the factory is the main hub. Contained in it are a bunch of exits that connect to various subareas. It's a rectangular room with a series of doors. For right now, it can just be an empty room with a few doors in the middle.\n\n02/11/2022  1:17:56 PM\n\nAdding an entry to the roadmap: add level exits and scene transitions. As noted in the roadmap, scene transitions will be implemented using a scene transition manager, likely a singleton.",
    "1644713272" : "New idea for handling player controls: Control is used for context-sensitive actions. Currently the object being interacted with (e.g., an energy ball) polls that kind of input. But what about having the player poll that input instead and emit some kind of signal which can then be received by the object in question.\n\nThe way this would work is, every node belonging to a group with interactable objects connects to a signal in the player. When the player interacts with an object, they emit a signal containing their location. Then it's up to the object how they will respond to it.\n\nWait, that won't quite work. What I can do instead is have the player see what kind of object is at the spot where the player is and see what kind of object it is.\n\nExample: if the player is in front of an energy ball and they press Control, the player knows that they are trying to pick up the energy ball, so the correct function is called. Objects which can be interacted with belong to a specific group of nodes.\n\nI'll see what I can do once I go back into the editor. First I need to remind myself of how things work.",
    "1644974275" : "The UI and Menuing section of my design document is empty. I have not thought about the UI in the slightest. I will have to figure that one out over time. I might do some sketches later while listening to a backlog of videos.\n\nWhat information does the HUD contain?\n1. Health\n2. Current floor/room\n3. Number of robots destroyed\n\n02/16/2022  1:42:12 AM\n\nThe first sketch of the UI is a black background with white text and a white outline. That's just a start, though; more versions of the UI will come.\n\n02/16/2022  7:41:32 AM\n\nHow to make the HUD work in a level? For now I made the HUD a part of the scene. A reference to this scene (NodePath) is an exported property in the player scene.\n\n02/16/2022 10:52:04 AM\n\nI added the UI scene as an autoload. The HUD scene is a child of UI and can be accessed through a getter function.",
    "1645323445" : "Developing a plugin for creating bitmap fonts in Godot.\n\nThe general concept is to divide a texture into cells. Much like SpriteFrames, you specify how many rows and columns there are, aptly named vframes and h frames respectively. From that the plugin would deduce the size of each cell in pixels.\n\nYou specify which cell you want to map to a character via an index, which is used to calculate the exact offset in the texture where said character is found.\n\nIn order for all this to work, the font needs to remember some of its attributes when serialized. To that end I will use the font's metatable to hold such attributes.\n\nThe meta attributes I need are:\n\nvframes: A dictionary that maps each texture ID to an integer specifying the number of rows in the texture\n\nhframes: A dictionary that maps each texture ID to an integer specifying the number of columns in the texture\n\nchar_mappings: A dictionary that maps a character to an index in the given texture.\n\n02/19/2022  9:11:50 PM\n\nCurrently working on the texture part of the dialog. Will see if it saves correctly.\n\nUpdate: It works! Both saving and loading of these values works.\n\n02/19/2022  9:25:04 PM\n\nNow working on the character mapping part of the dialog.\n\nUpdate: The character mappings are saved to the metatable as well. And now they are loaded into the dialog.",
    "1645367859" : "Still working on the character mappings in the bitmap font plugin. Right now I am adding each character to the font, and for that I need a few additional bits of information.\n\nSpecifically, I need the v and h frames. I'll use that to figure out the size of a cell.\n\n02/20/2022  9:58:50 AM\n\nCharacters are added to the font resource upon save.\n\nThe next order of business is to allow multiple textures per font. To do this, we will first make sure that the dialog properly saves the numeric ID of the texture for each character being mapped, to the metatable.\n\nFirst, we create a signal for the textures tab: texture_count_changed. It is emitted whenever the total amount of textures available has changed. The dialog root, we'll call it, connects with this signal and responds to it by setting the texture count in the character mapping tab. Said tab sets the texture count for each individual mapping.\n\nNext we want to transfer the texture ID chosen by the user, to the font. We do that the same way we get the index and character, via the node's properties. This is demonstrated well in CharacterMappings.gd.\n\n02/20/2022 11:03:08 AM\n\nA signal is emitted when a character mapping is added. The dialog responds by setting the texture count for that node. To make it work, the dialog also keeps a tally of the texture count, and updates that tally when the actual count changes.",
    "1645383820" : "I decided to make a new Github repository for my plugin since it got too big...And I wanted to make a separate project just to make it easier to test it.\n\n02/20/2022  3:58:32 PM\n\nI've finished the skeleton of the plugin, as it were. That is to say, I made the plugin work, though I do expect to see bugs down the line. I do not think this plugin is ready for production use--unless it's used by me, anyway."
}
